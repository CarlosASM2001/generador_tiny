token COMENTARIO
token COMENTARIO_LINEA
token GLOBAL
token ID
token SEMI
token GLOBAL
	 declaracion global variable
	 declaracion unica
token ID
token COLON
token ARRAY
token LBRACKET
token NUM
token RBRACKET
token SEMI
token COMENTARIO_LINEA
token BEGIN
	 declaracion global array
	 secuencia declaraciones
token VAR
token ID
token SEMI
token VAR
	 declaracion variable local
	 sentencia unica
token ID
token SEMI
token VAR
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
token COMENTARIO_LINEA
token READ
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
	 read variable
	 secuencia sentencias sin punto y coma
token COMENTARIO_LINEA
token FOR
token ID
token ASSIGN
token NUM
token TO
	 numero entero
token NUM
token STEP
	 numero entero
token NUM
token ID
	 numero entero
token LBRACKET
token ID
token RBRACKET
	 identificador
token ASSIGN
token ID
token TIMES
	 identificador
token NUM
token PLUS
	 numero entero
	 multiplicacion
token NUM
token SEMI
	 numero entero
	 suma
	 asignacion array
	 sentencia unica
token WRITE
token ID
token LBRACKET
token ID
token RBRACKET
	 identificador
token COMENTARIO_LINEA
token END
	 acceso array
	 write expresion
	 secuencia sentencias
token SEMI
	 for con step
	 secuencia sentencias
token COMENTARIO_LINEA
token IF
token ID
token GE
	 identificador
token NUM
token AND
	 numero entero
	 operacion mayor igual
token ID
token LE
	 identificador
token NUM
token THEN
	 numero entero
	 operacion menor igual
	 operacion AND
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 sentencia unica
token COMENTARIO_LINEA
token IF
token ID
token MOD
	 identificador
token NUM
token EQ
	 numero entero
	 modulo
token NUM
token THEN
	 numero entero
	 operacion igual
token WRITE
token NUM
token ELSE
	 numero entero
	 write expresion
	 sentencia unica
token WRITE
token NUM
token END
	 numero entero
	 write expresion
	 sentencia unica
token SEMI
	 if-else
	 secuencia sentencias
token COMENTARIO_LINEA
token ID
token ASSIGN
token ID
token POW
	 identificador
token NUM
token SEMI
	 numero entero
	 potencia
	 asignacion variable
	 secuencia sentencias
token WRITE
token ID
token ELSE
	 identificador
	 write expresion
	 secuencia sentencias
token WRITE
token NUM
token END
	 numero entero
	 write expresion
	 sentencia unica
token SEMI
	 if-else
	 secuencia sentencias
token COMENTARIO_LINEA
token ID
token ASSIGN
token CALL
token ID
token LPAREN
token ID
token COMMA
	 identificador
token NUM
token RPAREN
	 numero entero
	 lista argumentos
token SEMI
	 llamada funcion en expresion
	 asignacion variable
	 secuencia sentencias
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 secuencia sentencias
token COMENTARIO_LINEA
token IF
token LPAREN
token ID
token GT
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion mayor
token OR
	 expresion parentesis
token LPAREN
token ID
token LT
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion menor
token THEN
	 expresion parentesis
	 operacion OR
token WRITE
token NUM
token END
	 numero entero
	 write expresion
	 sentencia unica
token SEMI
	 if simple
	 secuencia sentencias
token IF
token NOT
token LPAREN
token ID
token NE
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion diferente
token THEN
	 expresion parentesis
	 operacion NOT
token WRITE
token NUM
token END
	 numero entero
	 write expresion
	 sentencia unica
token END
	 if simple
	 secuencia sentencias
token COMENTARIO_LINEA
token FUNCTION
Syntax error
instead expected token classes are [EOF]
token ID
token LPAREN
token ID
token COLON
token ARRAY
token LBRACKET
token RBRACKET
token COMMA
token ID
token RPAREN
token BEGIN
token VAR
token ID
token SEMI
token VAR
	 error en sentencia
Error sintáctico en sentencia
	 secuencia sentencias sin punto y coma
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
token ID
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ASSIGN
token NUM
token SEMI
	 numero entero
	 asignacion variable
	 secuencia sentencias sin punto y coma
token FOR
token ID
token ASSIGN
token NUM
token TO
	 numero entero
token ID
token MINUS
	 identificador
token NUM
token STEP
	 numero entero
	 resta
token NUM
token ID
	 numero entero
token ASSIGN
token ID
token PLUS
	 identificador
token ID
token LBRACKET
token ID
token RBRACKET
	 identificador
token SEMI
	 acceso array
	 suma
	 asignacion variable
	 sentencia unica
token IF
token ID
token LBRACKET
token ID
token RBRACKET
	 identificador
token LT
	 acceso array
token NUM
token THEN
	 numero entero
	 operacion menor
token CONTINUE
token END
	 continue
	 sentencia unica
token SEMI
	 if simple
	 secuencia sentencias
token IF
token ID
token GT
	 identificador
token NUM
token THEN
	 numero entero
	 operacion mayor
token BREAK
token END
	 break
	 sentencia unica
token END
	 if simple
	 secuencia sentencias
token SEMI
	 for con step
	 secuencia sentencias
token RETURN
token ID
token END
	 identificador
	 return con valor
	 secuencia sentencias
	 programa principal
	 regla programa completo

IMPRESION DEL AST GENERADO

  Tipo de nodo desconocido
Array arr ocupa 10 posiciones de memoria
*** Tabla de Simbolos ***
Total de posiciones de memoria utilizadas: 17
Variable: arr -> Direccion: 1
Variable: total -> Direccion: 14
Variable: resultado -> Direccion: 13
Variable: size -> Direccion: 15
Variable: v -> Direccion: 16
Variable: num -> Direccion: 12
Variable: x -> Direccion: 0
Variable: i -> Direccion: 11


------ CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------


* Compilacion TINY EXTENDIDO para el codigo objeto TM
* Archivo: programa_extendido.tiny
* Preludio estandar:
0:      LD        6,0(0)        cargar la maxima direccion desde la localidad 0
1:      ST        0,0(0)        limpio el registro de la localidad 0
2:      LDC       5,0(0)        GP apunta al inicio de variables globales (direccion 0)
* Total de memoria reservada para variables: 17 posiciones
* -> programa
* -> declaracion: x
* Declaracion de variable: x (global)
3:      LDC       0,0(0)        global: inicializar variable x a cero
4:      ST        0,0(5)        global: almacenar en direccion 0
* <- declaracion
* -> declaracion: arr
* Declaracion de array: arr tamaño definido
* -> constante
5:      LDC       0,10(0)       cargar constante: 10
* <- constante
6:      LDC       0,0(0)        array: inicializar elemento 0 a cero
7:      ST        0,1(5)        array: almacenar en posicion 1
8:      LDC       0,0(0)        array: inicializar elemento 1 a cero
9:      ST        0,2(5)        array: almacenar en posicion 2
10:     LDC       0,0(0)        array: inicializar elemento 2 a cero
11:     ST        0,3(5)        array: almacenar en posicion 3
12:     LDC       0,0(0)        array: inicializar elemento 3 a cero
13:     ST        0,4(5)        array: almacenar en posicion 4
14:     LDC       0,0(0)        array: inicializar elemento 4 a cero
15:     ST        0,5(5)        array: almacenar en posicion 5
16:     LDC       0,0(0)        array: inicializar elemento 5 a cero
17:     ST        0,6(5)        array: almacenar en posicion 6
18:     LDC       0,0(0)        array: inicializar elemento 6 a cero
19:     ST        0,7(5)        array: almacenar en posicion 7
20:     LDC       0,0(0)        array: inicializar elemento 7 a cero
21:     ST        0,8(5)        array: almacenar en posicion 8
22:     LDC       0,0(0)        array: inicializar elemento 8 a cero
23:     ST        0,9(5)        array: almacenar en posicion 9
24:     LDC       0,0(0)        array: inicializar elemento 9 a cero
25:     ST        0,10(5)       array: almacenar en posicion 10
* <- declaracion
* -> declaracion: i
* Declaracion de variable: i (local)
26:     LDC       0,0(0)        local: inicializar variable i a cero
27:     ST        0,11(5)       local: almacenar en direccion 11
* <- declaracion
* -> declaracion: num
* Declaracion de variable: num (local)
28:     LDC       0,0(0)        local: inicializar variable num a cero
29:     ST        0,12(5)       local: almacenar en direccion 12
* <- declaracion
* -> declaracion: resultado
* Declaracion de variable: resultado (local)
30:     LDC       0,0(0)        local: inicializar variable resultado a cero
31:     ST        0,13(5)       local: almacenar en direccion 13
* <- declaracion
* -> leer
32:     IN        0,0,0         leer: lee un valor entero 
33:     ST        0,12(5)       leer: almaceno el valor entero leido en el id num
* <- leer
* -> for
* -> constante
34:     LDC       0,0(0)        cargar constante: 0
* <- constante
35:     ST        0,11(5)       for: inicializar variable i
* for: inicio del bucle
36:     LD        0,11(5)       for: cargar variable de control
37:     ST        0,0(6)        for: guardar variable en pila temp
* -> constante
38:     LDC       0,9(0)        cargar constante: 9
* <- constante
39:     LD        1,0(6)        for: cargar variable de pila temp
40:     SUB       0,1,0         for: variable - valor_final
* for: salto condicional al final
* -> asignacion
* -> Operacion: mas
* -> Operacion: por
* -> identificador
42:     LD        0,11(5)       cargar valor de identificador: i
* <- identificador
43:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
44:     LDC       0,2(0)        cargar constante: 2
* <- constante
45:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
46:     MUL       0,1,0         op: *
* <- Operacion: por
47:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
48:     LDC       0,1(0)        cargar constante: 1
* <- constante
49:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
50:     ADD       0,1,0         op: +
* <- Operacion: mas
51:     ST        0,0(6)        asignacion array: guardar valor
* -> identificador
52:     LD        0,11(5)       cargar valor de identificador: i
* <- identificador
53:     LDC       1,1(0)        asignacion array: cargar direccion base
54:     ADD       0,0,1         asignacion array: calcular direccion
55:     LD        1,0(6)        asignacion array: recuperar valor
56:     ST        1,0(0)        asignacion array: almacenar en posicion calculada
* <- asignacion
* -> escribir
* -> identificador
* -> identificador
57:     LD        0,11(5)       cargar valor de identificador: i
* <- identificador
58:     LDC       1,1(0)        identificador array: cargar direccion base
59:     ADD       0,0,1         identificador array: calcular direccion
* <- identificador
60:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* for: punto de continue
61:     LD        0,11(5)       for: cargar variable para incremento
62:     ST        0,0(6)        for: guardar variable en pila temp
* -> constante
63:     LDC       0,1(0)        cargar constante: 1
* <- constante
64:     LD        1,0(6)        for: cargar variable de pila temp
65:     ADD       0,1,0         for: incrementar variable
66:     ST        0,11(5)       for: guardar variable incrementada
67:     LDA       7,-32(7)      for: salto al inicio
* for: fin del bucle
41:     JGT       0,26(7)       for: saltar si variable > final
* <- for
* -> if
* -> Operacion: and
* -> Operacion: mayorigual
* -> identificador
68:     LD        0,12(5)       cargar valor de identificador: num
* <- identificador
69:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
70:     LDC       0,0(0)        cargar constante: 0
* <- constante
71:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
72:     SUB       0,1,0         op: >=
73:     JGE       0,2(7)        saltar si AC>=0
74:     LDC       0,0(0)        caso falso
75:     LDC       2,0(0)        cargar 0 en registro 2
76:     JEQ       2,1(7)        salto incondicional
77:     LDC       0,1(0)        caso verdadero
* <- Operacion: mayorigual
78:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> Operacion: menorigual
* -> identificador
79:     LD        0,12(5)       cargar valor de identificador: num
* <- identificador
80:     ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
81:     LDC       0,10(0)       cargar constante: 10
* <- constante
82:     LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
83:     SUB       0,1,0         op: <=
84:     JLE       0,2(7)        saltar si AC<=0
85:     LDC       0,0(0)        caso falso
86:     LDC       2,0(0)        cargar 0 en registro 2
87:     JEQ       2,1(7)        salto incondicional
88:     LDC       0,1(0)        caso verdadero
* <- Operacion: menorigual
89:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
90:     JEQ       1,3(7)        and: si izquierdo es falso, resultado es falso
91:     JEQ       0,2(7)        and: si derecho es falso, resultado es falso
92:     LDC       0,1(0)        and: ambos verdaderos
93:     LDC       2,0(0)        cargar 0 en registro 2
94:     JEQ       2,1(7)        and: salto incondicional
95:     LDC       0,0(0)        and: resultado falso
* <- Operacion: and
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> identificador
97:     LD        0,12(5)       cargar valor de identificador: num
* <- identificador
98:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> if
* -> Operacion: igual
* -> Operacion: modulo
* -> identificador
99:     LD        0,12(5)       cargar valor de identificador: num
* <- identificador
100:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
101:    LDC       0,2(0)        cargar constante: 2
* <- constante
102:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
103:    ST        0,0(6)        mod: guardar b
104:    ST        1,-1(6)       mod: guardar a
105:    DIV       0,1,0         mod: a/b
106:    LD        1,-1(6)       mod: recuperar a
107:    LD        2,0(6)        mod: recuperar b en r2
108:    MUL       0,0,2         mod: (a/b)*b
109:    SUB       0,1,0         mod: a - (a/b)*b
* <- Operacion: modulo
110:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
111:    LDC       0,0(0)        cargar constante: 0
* <- constante
112:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
113:    SUB       0,1,0         op: ==
114:    JEQ       0,2(7)        voy dos instrucciones mas alla if verdadero (AC==0)
115:    LDC       0,0(0)        caso de falso (AC=0)
116:    LDC       2,0(0)        cargar 0 en registro 2
117:    JEQ       2,1(7)        salto incondicional
118:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: igual
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> constante
120:    LDC       0,1(0)        cargar constante: 1
* <- constante
121:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
119:    JEQ       0,3(7)        if: jmp hacia else
* -> escribir
* -> constante
123:    LDC       0,0(0)        cargar constante: 0
* <- constante
124:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
122:    LDA       7,2(7)        if: jmp hacia el final
* <- if
* -> asignacion
* -> Operacion: potencia
* -> identificador
125:    LD        0,12(5)       cargar valor de identificador: num
* <- identificador
126:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
127:    LDC       0,2(0)        cargar constante: 2
* <- constante
128:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
* potencia: implementación simplificada base^exponente
129:    MUL       0,1,1         potencia: base * base (para x^2)
* <- Operacion: potencia
130:    ST        0,0(5)        asignacion: almaceno el valor para el id x
* <- asignacion
* -> escribir
* -> identificador
131:    LD        0,0(5)        cargar valor de identificador: x
* <- identificador
132:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
96:     JEQ       0,37(7)       if: jmp hacia else
* -> escribir
* -> constante
134:    LDC       0,999(0)      cargar constante: 999
* <- constante
135:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
133:    LDA       7,2(7)        if: jmp hacia el final
* <- if
* -> asignacion
* -> llamada funcion: suma_vector
136:    ST        7,0(6)        call: guardar direccion de retorno
* Procesando argumentos de la llamada
* -> identificador
137:    LD        0,1(5)        cargar valor de identificador: arr
* <- identificador
* -> constante
138:    LDC       0,10(0)       cargar constante: 10
* <- constante
139:    ST        0,-1(6)       call: guardar argumento
* -> constante
140:    LDC       0,10(0)       cargar constante: 10
* <- constante
141:    ST        0,-2(6)       call: guardar argumento
* Implementación real de suma_vector
142:    LDC       0,0(0)        suma_vector: inicializar total = 0
143:    ST        0,-3(6)       suma_vector: guardar total
144:    LDC       0,0(0)        suma_vector: inicializar i = 0
145:    ST        0,-4(6)       suma_vector: guardar i
* suma_vector: inicio del loop
146:    LD        0,-4(6)       suma_vector: cargar i
147:    LDC       1,10(0)       suma_vector: cargar limite 10
148:    SUB       0,0,1         suma_vector: i - 10
150:    LD        0,-4(6)       suma_vector: cargar i
151:    LDC       1,1(0)        suma_vector: base del array
152:    ADD       0,0,1         suma_vector: calcular direccion arr[i]
153:    LD        0,0(0)        suma_vector: cargar arr[i]
154:    LD        1,-3(6)       suma_vector: cargar total
155:    ADD       0,0,1         suma_vector: total + arr[i]
156:    ST        0,-3(6)       suma_vector: guardar nuevo total
157:    LD        0,-4(6)       suma_vector: cargar i
158:    LDC       1,1(0)        suma_vector: cargar 1
159:    ADD       0,0,1         suma_vector: i + 1
160:    ST        0,-4(6)       suma_vector: guardar i++
161:    LDA       7,-16(7)      suma_vector: repetir loop
* suma_vector: fin del loop
149:    JGE       0,12(7)       suma_vector: saltar si i >= 10
162:    LD        0,-3(6)       suma_vector: cargar resultado final
* <- llamada funcion
163:    ST        0,13(5)       asignacion: almaceno el valor para el id resultado
* <- asignacion
* -> escribir
* -> identificador
164:    LD        0,13(5)       cargar valor de identificador: resultado
* <- identificador
165:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> if
* -> Operacion: or
* -> Operacion: mayor
* -> identificador
166:    LD        0,12(5)       cargar valor de identificador: num
* <- identificador
167:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
168:    LDC       0,5(0)        cargar constante: 5
* <- constante
169:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
170:    SUB       0,1,0         op: >
171:    JGT       0,2(7)        saltar si AC>0
172:    LDC       0,0(0)        caso falso
173:    LDC       2,0(0)        cargar 0 en registro 2
174:    JEQ       2,1(7)        salto incondicional
175:    LDC       0,1(0)        caso verdadero
* <- Operacion: mayor
176:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> Operacion: menor
* -> identificador
177:    LD        0,12(5)       cargar valor de identificador: num
* <- identificador
178:    ST        0,-4(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
179:    LDC       0,0(0)        cargar constante: 0
* <- constante
180:    LD        1,-4(6)       op: pop o cargo de la pila el valor izquierdo en AC1
181:    SUB       0,1,0         op: <
182:    JLT       0,2(7)        voy dos instrucciones mas alla if verdadero (AC<0)
183:    LDC       0,0(0)        caso de falso (AC=0)
184:    LDC       2,0(0)        cargar 0 en registro 2
185:    JEQ       2,1(7)        salto incondicional
186:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: menor
187:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
188:    JNE       1,3(7)        or: si izquierdo es verdadero, resultado es verdadero
189:    JNE       0,2(7)        or: si derecho es verdadero, resultado es verdadero
190:    LDC       0,0(0)        or: ambos falsos
191:    LDC       2,0(0)        cargar 0 en registro 2
192:    JEQ       2,1(7)        or: salto incondicional
193:    LDC       0,1(0)        or: resultado verdadero
* <- Operacion: or
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> constante
195:    LDC       0,1(0)        cargar constante: 1
* <- constante
196:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
194:    JEQ       0,3(7)        if: jmp hacia else
* <- if
* -> if
* -> Operacion: not
* -> Operacion: diferente
* -> identificador
198:    LD        0,12(5)       cargar valor de identificador: num
* <- identificador
199:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
200:    LDC       0,5(0)        cargar constante: 5
* <- constante
201:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
202:    SUB       0,1,0         op: !=
203:    JNE       0,2(7)        saltar si AC!=0
204:    LDC       0,0(0)        caso falso
205:    LDC       2,0(0)        cargar 0 en registro 2
206:    JEQ       2,1(7)        salto incondicional
207:    LDC       0,1(0)        caso verdadero
* <- Operacion: diferente
208:    JEQ       0,2(7)        not: saltar si es cero (falso)
209:    LDC       0,0(0)        not: resultado falso
210:    LDC       2,0(0)        not: cargar 0 en registro 2
211:    JEQ       2,1(7)        not: salto incondicional
212:    LDC       0,1(0)        not: resultado verdadero
* <- Operacion: not
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> constante
214:    LDC       0,5(0)        cargar constante: 5
* <- constante
215:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
213:    JEQ       0,3(7)        if: jmp hacia else
* <- if
* -> declaracion: i
* Declaracion de variable: i (local)
217:    LDC       0,0(0)        local: inicializar variable i a cero
218:    ST        0,11(5)       local: almacenar en direccion 11
* <- declaracion
* -> declaracion: total
* Declaracion de variable: total (local)
219:    LDC       0,0(0)        local: inicializar variable total a cero
220:    ST        0,14(5)       local: almacenar en direccion 14
* <- declaracion
* -> asignacion
* -> constante
221:    LDC       0,0(0)        cargar constante: 0
* <- constante
222:    ST        0,14(5)       asignacion: almaceno el valor para el id total
* <- asignacion
* -> for
* -> constante
223:    LDC       0,0(0)        cargar constante: 0
* <- constante
224:    ST        0,11(5)       for: inicializar variable i
* for: inicio del bucle
225:    LD        0,11(5)       for: cargar variable de control
226:    ST        0,-3(6)       for: guardar variable en pila temp
* -> Operacion: menos
* -> identificador
227:    LD        0,15(5)       cargar valor de identificador: size
* <- identificador
228:    ST        0,-4(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
229:    LDC       0,1(0)        cargar constante: 1
* <- constante
230:    LD        1,-4(6)       op: pop o cargo de la pila el valor izquierdo en AC1
231:    SUB       0,1,0         op: -
* <- Operacion: menos
232:    LD        1,-3(6)       for: cargar variable de pila temp
233:    SUB       0,1,0         for: variable - valor_final
* for: salto condicional al final
* -> asignacion
* -> Operacion: mas
* -> identificador
235:    LD        0,14(5)       cargar valor de identificador: total
* <- identificador
236:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> identificador
* -> identificador
237:    LD        0,11(5)       cargar valor de identificador: i
* <- identificador
238:    LDC       1,16(0)       identificador array: cargar direccion base
239:    ADD       0,0,1         identificador array: calcular direccion
* <- identificador
240:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
241:    ADD       0,1,0         op: +
* <- Operacion: mas
242:    ST        0,14(5)       asignacion: almaceno el valor para el id total
* <- asignacion
* -> if
* -> Operacion: menor
* -> identificador
* -> identificador
243:    LD        0,11(5)       cargar valor de identificador: i
* <- identificador
244:    LDC       1,16(0)       identificador array: cargar direccion base
245:    ADD       0,0,1         identificador array: calcular direccion
* <- identificador
246:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
247:    LDC       0,0(0)        cargar constante: 0
* <- constante
248:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
249:    SUB       0,1,0         op: <
250:    JLT       0,2(7)        voy dos instrucciones mas alla if verdadero (AC<0)
251:    LDC       0,0(0)        caso de falso (AC=0)
252:    LDC       2,0(0)        cargar 0 en registro 2
253:    JEQ       2,1(7)        salto incondicional
254:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: menor
* If: el salto hacia el else debe estar aqui
* -> continue
* continue: salto al incremento del bucle
* <- continue
* If: el salto hacia el final debe estar aqui
255:    JEQ       0,1(7)        if: jmp hacia else
* <- if
* -> if
* -> Operacion: mayor
* -> identificador
257:    LD        0,14(5)       cargar valor de identificador: total
* <- identificador
258:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
259:    LDC       0,200(0)      cargar constante: 200
* <- constante
260:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
261:    SUB       0,1,0         op: >
262:    JGT       0,2(7)        saltar si AC>0
263:    LDC       0,0(0)        caso falso
264:    LDC       2,0(0)        cargar 0 en registro 2
265:    JEQ       2,1(7)        salto incondicional
266:    LDC       0,1(0)        caso verdadero
* <- Operacion: mayor
* If: el salto hacia el else debe estar aqui
* -> break
* break: salto al final del bucle
* <- break
* If: el salto hacia el final debe estar aqui
267:    JEQ       0,1(7)        if: jmp hacia else
* <- if
* for: punto de continue
269:    LD        0,11(5)       for: cargar variable para incremento
270:    ST        0,-3(6)       for: guardar variable en pila temp
* -> constante
271:    LDC       0,1(0)        cargar constante: 1
* <- constante
272:    LD        1,-3(6)       for: cargar variable de pila temp
273:    ADD       0,1,0         for: incrementar variable
274:    ST        0,11(5)       for: guardar variable incrementada
275:    LDA       7,-51(7)      for: salto al inicio
* for: fin del bucle
234:    JGT       0,41(7)       for: saltar si variable > final
* <- for
* -> return
* -> identificador
276:    LD        0,14(5)       cargar valor de identificador: total
* <- identificador
277:    LD        1,-2(6)       return: restaurar frame
278:    LD        7,0(1)        return: salto a direccion de retorno
* <- return
* <- programa
* Fin de la ejecucion.
279:    HALT      0,0,0         


------ FIN DEL CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------
