token COMENTARIO
token COMENTARIO_LINEA
token GLOBAL
token ID
token SEMI
token GLOBAL
	 declaracion global variable
	 declaracion unica
token ID
token COLON
token ARRAY
token LBRACKET
token NUM
token RBRACKET
token SEMI
token COMENTARIO_LINEA
token BEGIN
	 declaracion global array
	 secuencia declaraciones
token VAR
token ID
token SEMI
token VAR
	 declaracion variable local
	 sentencia unica
token ID
token SEMI
token VAR
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
token COMENTARIO_LINEA
token READ
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
	 read variable
	 secuencia sentencias sin punto y coma
token COMENTARIO_LINEA
token FOR
token ID
token ASSIGN
token NUM
token TO
	 numero entero
token NUM
token STEP
	 numero entero
token NUM
token ID
	 numero entero
token LBRACKET
token ID
token RBRACKET
	 identificador
token ASSIGN
token ID
token TIMES
	 identificador
token NUM
token PLUS
	 numero entero
	 multiplicacion
token NUM
token END
	 numero entero
	 suma
	 asignacion array
	 sentencia unica
token SEMI
	 for con step
	 secuencia sentencias
token COMENTARIO_LINEA
token IF
token ID
token GE
	 identificador
token NUM
token AND
	 numero entero
	 operacion mayor igual
token ID
token LE
	 identificador
token NUM
token THEN
	 numero entero
	 operacion menor igual
	 operacion AND
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 sentencia unica
token COMENTARIO_LINEA
token IF
token ID
token MOD
	 identificador
token NUM
token EQ
	 numero entero
	 modulo
token NUM
token THEN
	 numero entero
	 operacion igual
token WRITE
token NUM
token ELSE
	 numero entero
	 write expresion
	 sentencia unica
token WRITE
token NUM
token END
	 numero entero
	 write expresion
	 sentencia unica
token SEMI
	 if-else
	 secuencia sentencias
token COMENTARIO_LINEA
token ID
token ASSIGN
token ID
token POW
	 identificador
token NUM
token SEMI
	 numero entero
	 potencia
	 asignacion variable
	 secuencia sentencias
token WRITE
token ID
token ELSE
	 identificador
	 write expresion
	 secuencia sentencias
token WRITE
token NUM
token END
	 numero entero
	 write expresion
	 sentencia unica
token SEMI
	 if-else
	 secuencia sentencias
token COMENTARIO_LINEA
token ID
token ASSIGN
token CALL
token ID
token LPAREN
token ID
token COMMA
	 identificador
token NUM
token RPAREN
	 numero entero
	 lista argumentos
token SEMI
	 llamada funcion en expresion
	 asignacion variable
	 secuencia sentencias
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 secuencia sentencias
token COMENTARIO_LINEA
token IF
token LPAREN
token ID
token GT
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion mayor
token OR
	 expresion parentesis
token LPAREN
token ID
token LT
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion menor
token THEN
	 expresion parentesis
	 operacion OR
token WRITE
token NUM
token END
	 numero entero
	 write expresion
	 sentencia unica
token SEMI
	 if simple
	 secuencia sentencias
token IF
token NOT
token LPAREN
token ID
token NE
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion diferente
token THEN
	 expresion parentesis
	 operacion NOT
token WRITE
token NUM
token END
	 numero entero
	 write expresion
	 sentencia unica
token END
	 if simple
	 secuencia sentencias
token COMENTARIO_LINEA
token FUNCTION
Syntax error
instead expected token classes are [EOF]
token ID
token LPAREN
token ID
token COLON
token ARRAY
token LBRACKET
token RBRACKET
token COMMA
token ID
token RPAREN
token BEGIN
token VAR
token ID
token SEMI
token VAR
	 error en sentencia
Error sintáctico en sentencia
	 secuencia sentencias sin punto y coma
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
token ID
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ASSIGN
token NUM
token SEMI
	 numero entero
	 asignacion variable
	 secuencia sentencias sin punto y coma
token FOR
token ID
token ASSIGN
token NUM
token TO
	 numero entero
token ID
token MINUS
	 identificador
token NUM
token STEP
	 numero entero
	 resta
token NUM
token ID
	 numero entero
token ASSIGN
token ID
token PLUS
	 identificador
token ID
token LBRACKET
token ID
token RBRACKET
	 identificador
token SEMI
	 acceso array
	 suma
	 asignacion variable
	 sentencia unica
token IF
token ID
token LBRACKET
token ID
token RBRACKET
	 identificador
token LT
	 acceso array
token NUM
token THEN
	 numero entero
	 operacion menor
token CONTINUE
token END
	 continue
	 sentencia unica
token SEMI
	 if simple
	 secuencia sentencias
token IF
token ID
token GT
	 identificador
token NUM
token THEN
	 numero entero
	 operacion mayor
token BREAK
token END
	 break
	 sentencia unica
token END
	 if simple
	 secuencia sentencias
token SEMI
	 for con step
	 secuencia sentencias
token RETURN
token ID
token END
	 identificador
	 return con valor
	 secuencia sentencias
	 programa principal
	 regla programa completo

IMPRESION DEL AST GENERADO

  Tipo de nodo desconocido
Array arr ocupa 10 posiciones de memoria
*** Tabla de Simbolos ***
Total de posiciones de memoria utilizadas: 17
Variable: arr -> Direccion: 1
Variable: total -> Direccion: 14
Variable: resultado -> Direccion: 13
Variable: size -> Direccion: 15
Variable: v -> Direccion: 16
Variable: num -> Direccion: 12
Variable: x -> Direccion: 0
Variable: i -> Direccion: 11


------ CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------


* Compilacion TINY EXTENDIDO para el codigo objeto TM
* Archivo: programa_extendido.tiny
* Preludio estandar:
0:      LD        6,0(0)        cargar la maxima direccion desde la localidad 0
1:      ST        0,0(0)        limpio el registro de la localidad 0
2:      LDC       5,0(0)        GP apunta al inicio de variables globales (direccion 0)
* Total de memoria reservada para variables: 17 posiciones
* -> programa
* -> declaracion: x
* Declaracion de variable: x (global)
3:      LDC       0,0(0)        global: inicializar variable x a cero
4:      ST        0,0(5)        global: almacenar en direccion 0
* <- declaracion
* -> declaracion: arr
* Declaracion de array: arr tamaño definido
* -> constante
5:      LDC       0,10(0)       cargar constante: 10
* <- constante
6:      LDC       0,0(0)        array: inicializar elemento 0 a cero
7:      ST        0,1(5)        array: almacenar en posicion 1
8:      LDC       0,0(0)        array: inicializar elemento 1 a cero
9:      ST        0,2(5)        array: almacenar en posicion 2
10:     LDC       0,0(0)        array: inicializar elemento 2 a cero
11:     ST        0,3(5)        array: almacenar en posicion 3
12:     LDC       0,0(0)        array: inicializar elemento 3 a cero
13:     ST        0,4(5)        array: almacenar en posicion 4
14:     LDC       0,0(0)        array: inicializar elemento 4 a cero
15:     ST        0,5(5)        array: almacenar en posicion 5
16:     LDC       0,0(0)        array: inicializar elemento 5 a cero
17:     ST        0,6(5)        array: almacenar en posicion 6
18:     LDC       0,0(0)        array: inicializar elemento 6 a cero
19:     ST        0,7(5)        array: almacenar en posicion 7
20:     LDC       0,0(0)        array: inicializar elemento 7 a cero
21:     ST        0,8(5)        array: almacenar en posicion 8
22:     LDC       0,0(0)        array: inicializar elemento 8 a cero
23:     ST        0,9(5)        array: almacenar en posicion 9
24:     LDC       0,0(0)        array: inicializar elemento 9 a cero
25:     ST        0,10(5)       array: almacenar en posicion 10
* <- declaracion
* -> declaracion: i
* Declaracion de variable: i (local)
26:     LDC       0,0(0)        local: inicializar variable i a cero
27:     ST        0,11(5)       local: almacenar en direccion 11
* <- declaracion
* -> declaracion: num
* Declaracion de variable: num (local)
28:     LDC       0,0(0)        local: inicializar variable num a cero
29:     ST        0,12(5)       local: almacenar en direccion 12
* <- declaracion
* -> declaracion: resultado
* Declaracion de variable: resultado (local)
30:     LDC       0,0(0)        local: inicializar variable resultado a cero
31:     ST        0,13(5)       local: almacenar en direccion 13
* <- declaracion
* -> leer
32:     IN        0,0,0         leer: lee un valor entero 
33:     ST        0,12(5)       leer: almaceno el valor entero leido en el id num
* <- leer
* -> for
* -> constante
34:     LDC       0,0(0)        cargar constante: 0
* <- constante
35:     ST        0,11(5)       for: inicializar variable i
* for: inicio del bucle
36:     LD        0,11(5)       for: cargar variable de control
37:     ST        0,0(6)        for: guardar variable en pila temp
* -> constante
38:     LDC       0,9(0)        cargar constante: 9
* <- constante
39:     LD        1,0(6)        for: cargar variable de pila temp
40:     SUB       0,1,0         for: variable - valor_final
* for: salto condicional al final
* -> asignacion
* -> Operacion: mas
* -> Operacion: por
* -> identificador
42:     LD        0,11(5)       cargar valor de identificador: i
* <- identificador
43:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
44:     LDC       0,2(0)        cargar constante: 2
* <- constante
45:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
46:     MUL       0,1,0         op: *
* <- Operacion: por
47:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
48:     LDC       0,1(0)        cargar constante: 1
* <- constante
49:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
50:     ADD       0,1,0         op: +
* <- Operacion: mas
51:     ST        0,0(6)        asignacion array: guardar valor
* -> identificador
52:     LD        0,11(5)       cargar valor de identificador: i
* <- identificador
53:     LDC       1,1(0)        asignacion array: cargar direccion base
54:     ADD       0,0,1         asignacion array: calcular direccion
55:     LD        1,0(6)        asignacion array: recuperar valor
56:     ST        1,0(0)        asignacion array: almacenar en posicion calculada
* <- asignacion
* for: punto de continue
57:     LD        0,11(5)       for: cargar variable para incremento
58:     ST        0,0(6)        for: guardar variable en pila temp
* -> constante
59:     LDC       0,1(0)        cargar constante: 1
* <- constante
60:     LD        1,0(6)        for: cargar variable de pila temp
61:     ADD       0,1,0         for: incrementar variable
62:     ST        0,11(5)       for: guardar variable incrementada
63:     LDA       7,-28(7)      for: salto al inicio
* for: fin del bucle
41:     JGT       0,22(7)       for: saltar si variable > final
* <- for
* -> if
* -> Operacion: and
* -> Operacion: mayorigual
* -> identificador
64:     LD        0,12(5)       cargar valor de identificador: num
* <- identificador
65:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
66:     LDC       0,0(0)        cargar constante: 0
* <- constante
67:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
68:     SUB       0,1,0         op: >=
69:     JGE       0,2(7)        saltar si AC>=0
70:     LDC       0,0(0)        caso falso
71:     LDA       7,1(7)        saltar caso verdadero
72:     LDC       0,1(0)        caso verdadero
* <- Operacion: mayorigual
73:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> Operacion: menorigual
* -> identificador
74:     LD        0,12(5)       cargar valor de identificador: num
* <- identificador
75:     ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
76:     LDC       0,10(0)       cargar constante: 10
* <- constante
77:     LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
78:     SUB       0,1,0         op: <=
79:     JLE       0,2(7)        saltar si AC<=0
80:     LDC       0,0(0)        caso falso
81:     LDA       7,1(7)        saltar caso verdadero
82:     LDC       0,1(0)        caso verdadero
* <- Operacion: menorigual
83:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
84:     JEQ       1,3(7)        and: si izquierdo es falso, resultado es falso
85:     JEQ       0,2(7)        and: si derecho es falso, resultado es falso
86:     LDC       0,1(0)        and: ambos verdaderos
87:     LDA       7,1(7)        and: saltar caso falso
88:     LDC       0,0(0)        and: resultado falso
* <- Operacion: and
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> identificador
90:     LD        0,12(5)       cargar valor de identificador: num
* <- identificador
91:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> if
* -> Operacion: igual
* -> Operacion: modulo
* -> identificador
92:     LD        0,12(5)       cargar valor de identificador: num
* <- identificador
93:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
94:     LDC       0,2(0)        cargar constante: 2
* <- constante
95:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
96:     ST        0,0(6)        mod: guardar b
97:     ST        1,-1(6)       mod: guardar a
98:     DIV       0,1,0         mod: a/b
99:     LD        1,-1(6)       mod: recuperar a
100:    LD        2,0(6)        mod: recuperar b en r2
101:    MUL       0,0,2         mod: (a/b)*b
102:    SUB       0,1,0         mod: a - (a/b)*b
* <- Operacion: modulo
103:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
104:    LDC       0,0(0)        cargar constante: 0
* <- constante
105:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
106:    SUB       0,1,0         op: ==
107:    JEQ       0,2(7)        voy dos instrucciones mas alla if verdadero (AC==0)
108:    LDC       0,0(0)        caso de falso (AC=0)
109:    LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
110:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: igual
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> constante
112:    LDC       0,1(0)        cargar constante: 1
* <- constante
113:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
111:    JEQ       0,3(7)        if: jmp hacia else
* -> escribir
* -> constante
115:    LDC       0,0(0)        cargar constante: 0
* <- constante
116:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
114:    LDA       7,2(7)        if: jmp hacia el final
* <- if
* -> asignacion
* -> Operacion: potencia
* -> identificador
117:    LD        0,12(5)       cargar valor de identificador: num
* <- identificador
118:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
119:    LDC       0,2(0)        cargar constante: 2
* <- constante
120:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
* potencia: implementación simplificada
121:    MUL       0,1,0         potencia: multiplicación simple
* <- Operacion: potencia
122:    ST        0,0(5)        asignacion: almaceno el valor para el id x
* <- asignacion
* -> escribir
* -> identificador
123:    LD        0,0(5)        cargar valor de identificador: x
* <- identificador
124:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
89:     JEQ       0,36(7)       if: jmp hacia else
* -> escribir
* -> constante
126:    LDC       0,999(0)      cargar constante: 999
* <- constante
127:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
125:    LDA       7,2(7)        if: jmp hacia el final
* <- if
* -> asignacion
* -> llamada funcion: suma_vector
128:    ST        7,0(6)        call: guardar direccion de retorno
* Procesando argumentos de la llamada
* -> identificador
129:    LD        0,1(5)        cargar valor de identificador: arr
* <- identificador
* -> constante
130:    LDC       0,10(0)       cargar constante: 10
* <- constante
131:    ST        0,-1(6)       call: guardar argumento
* -> constante
132:    LDC       0,10(0)       cargar constante: 10
* <- constante
133:    ST        0,-2(6)       call: guardar argumento
* Llamada a funcion suma_vector (implementación simplificada)
* <- llamada funcion
134:    ST        0,13(5)       asignacion: almaceno el valor para el id resultado
* <- asignacion
* -> escribir
* -> identificador
135:    LD        0,13(5)       cargar valor de identificador: resultado
* <- identificador
136:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> if
* -> Operacion: or
* -> Operacion: mayor
* -> identificador
137:    LD        0,12(5)       cargar valor de identificador: num
* <- identificador
138:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
139:    LDC       0,5(0)        cargar constante: 5
* <- constante
140:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
141:    SUB       0,1,0         op: >
142:    JGT       0,2(7)        saltar si AC>0
143:    LDC       0,0(0)        caso falso
144:    LDA       7,1(7)        saltar caso verdadero
145:    LDC       0,1(0)        caso verdadero
* <- Operacion: mayor
146:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> Operacion: menor
* -> identificador
147:    LD        0,12(5)       cargar valor de identificador: num
* <- identificador
148:    ST        0,-4(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
149:    LDC       0,0(0)        cargar constante: 0
* <- constante
150:    LD        1,-4(6)       op: pop o cargo de la pila el valor izquierdo en AC1
151:    SUB       0,1,0         op: <
152:    JLT       0,2(7)        voy dos instrucciones mas alla if verdadero (AC<0)
153:    LDC       0,0(0)        caso de falso (AC=0)
154:    LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
155:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: menor
156:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
157:    JNE       1,3(7)        or: si izquierdo es verdadero, resultado es verdadero
158:    JNE       0,2(7)        or: si derecho es verdadero, resultado es verdadero
159:    LDC       0,0(0)        or: ambos falsos
160:    LDA       7,1(7)        or: saltar caso verdadero
161:    LDC       0,1(0)        or: resultado verdadero
* <- Operacion: or
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> constante
163:    LDC       0,1(0)        cargar constante: 1
* <- constante
164:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
162:    JEQ       0,3(7)        if: jmp hacia else
* <- if
* -> if
* -> Operacion: not
* -> Operacion: diferente
* -> identificador
166:    LD        0,12(5)       cargar valor de identificador: num
* <- identificador
167:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
168:    LDC       0,5(0)        cargar constante: 5
* <- constante
169:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
170:    SUB       0,1,0         op: !=
171:    JNE       0,2(7)        saltar si AC!=0
172:    LDC       0,0(0)        caso falso
173:    LDA       7,1(7)        saltar caso verdadero
174:    LDC       0,1(0)        caso verdadero
* <- Operacion: diferente
175:    JEQ       0,2(7)        not: saltar si es cero (falso)
176:    LDC       0,0(0)        not: resultado falso
177:    LDA       7,1(7)        not: saltar carga de verdadero
178:    LDC       0,1(0)        not: resultado verdadero
* <- Operacion: not
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> constante
180:    LDC       0,5(0)        cargar constante: 5
* <- constante
181:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
179:    JEQ       0,3(7)        if: jmp hacia else
* <- if
* -> declaracion: i
* Declaracion de variable: i (local)
183:    LDC       0,0(0)        local: inicializar variable i a cero
184:    ST        0,11(5)       local: almacenar en direccion 11
* <- declaracion
* -> declaracion: total
* Declaracion de variable: total (local)
185:    LDC       0,0(0)        local: inicializar variable total a cero
186:    ST        0,14(5)       local: almacenar en direccion 14
* <- declaracion
* -> asignacion
* -> constante
187:    LDC       0,0(0)        cargar constante: 0
* <- constante
188:    ST        0,14(5)       asignacion: almaceno el valor para el id total
* <- asignacion
* -> for
* -> constante
189:    LDC       0,0(0)        cargar constante: 0
* <- constante
190:    ST        0,11(5)       for: inicializar variable i
* for: inicio del bucle
191:    LD        0,11(5)       for: cargar variable de control
192:    ST        0,-3(6)       for: guardar variable en pila temp
* -> Operacion: menos
* -> identificador
193:    LD        0,15(5)       cargar valor de identificador: size
* <- identificador
194:    ST        0,-4(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
195:    LDC       0,1(0)        cargar constante: 1
* <- constante
196:    LD        1,-4(6)       op: pop o cargo de la pila el valor izquierdo en AC1
197:    SUB       0,1,0         op: -
* <- Operacion: menos
198:    LD        1,-3(6)       for: cargar variable de pila temp
199:    SUB       0,1,0         for: variable - valor_final
* for: salto condicional al final
* -> asignacion
* -> Operacion: mas
* -> identificador
201:    LD        0,14(5)       cargar valor de identificador: total
* <- identificador
202:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> identificador
* -> identificador
203:    LD        0,11(5)       cargar valor de identificador: i
* <- identificador
204:    LDC       1,16(0)       identificador array: cargar direccion base
205:    ADD       0,0,1         identificador array: calcular direccion
* <- identificador
206:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
207:    ADD       0,1,0         op: +
* <- Operacion: mas
208:    ST        0,14(5)       asignacion: almaceno el valor para el id total
* <- asignacion
* -> if
* -> Operacion: menor
* -> identificador
* -> identificador
209:    LD        0,11(5)       cargar valor de identificador: i
* <- identificador
210:    LDC       1,16(0)       identificador array: cargar direccion base
211:    ADD       0,0,1         identificador array: calcular direccion
* <- identificador
212:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
213:    LDC       0,0(0)        cargar constante: 0
* <- constante
214:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
215:    SUB       0,1,0         op: <
216:    JLT       0,2(7)        voy dos instrucciones mas alla if verdadero (AC<0)
217:    LDC       0,0(0)        caso de falso (AC=0)
218:    LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
219:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: menor
* If: el salto hacia el else debe estar aqui
* -> continue
* continue: salto al incremento del bucle
* <- continue
* If: el salto hacia el final debe estar aqui
220:    JEQ       0,1(7)        if: jmp hacia else
* <- if
* -> if
* -> Operacion: mayor
* -> identificador
222:    LD        0,14(5)       cargar valor de identificador: total
* <- identificador
223:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
224:    LDC       0,200(0)      cargar constante: 200
* <- constante
225:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
226:    SUB       0,1,0         op: >
227:    JGT       0,2(7)        saltar si AC>0
228:    LDC       0,0(0)        caso falso
229:    LDA       7,1(7)        saltar caso verdadero
230:    LDC       0,1(0)        caso verdadero
* <- Operacion: mayor
* If: el salto hacia el else debe estar aqui
* -> break
* break: salto al final del bucle
* <- break
* If: el salto hacia el final debe estar aqui
231:    JEQ       0,1(7)        if: jmp hacia else
* <- if
* for: punto de continue
233:    LD        0,11(5)       for: cargar variable para incremento
234:    ST        0,-3(6)       for: guardar variable en pila temp
* -> constante
235:    LDC       0,1(0)        cargar constante: 1
* <- constante
236:    LD        1,-3(6)       for: cargar variable de pila temp
237:    ADD       0,1,0         for: incrementar variable
238:    ST        0,11(5)       for: guardar variable incrementada
239:    LDA       7,-49(7)      for: salto al inicio
* for: fin del bucle
200:    JGT       0,39(7)       for: saltar si variable > final
* <- for
* -> return
* -> identificador
240:    LD        0,14(5)       cargar valor de identificador: total
* <- identificador
241:    LD        1,-2(6)       return: restaurar frame
242:    LD        7,0(1)        return: salto a direccion de retorno
* <- return
* <- programa
* Fin de la ejecucion.
243:    HALT      0,0,0         


------ FIN DEL CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------
